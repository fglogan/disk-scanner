## **Tempext Engineering Standard (TES-2025) v6.9**
**CONFIDENTIAL & PROPRIETARY – INTERNAL USE ONLY**  
**Document KO_ID:** `Standard-TempextEngineering-v6.9.0`
**Status:** `Gold`  
**Version:** 6.9.0  
**Date:** September 19, 2025; 12:00 ET  
**Author:** F.G. Logan  
**Editor:** Gemini 2.5 Pro (as `LAIO_SystemAgent`)  

_This document is a `LAIO_Knowledge_Object` of the `Codex` class. Its evolution is governed by the principles it contains._

**AI Summary:** TES-2025 v6.9 is the comprehensive superset standard, building on v6.8 adding section 10 refinements. It reinforces the exclusion of human effort quantifiers in schedules

#### Preamble: The Architecture of Understanding
This document architects the engineering discipline at Tempext. Its structure is a deliberate embodiment of the cognitive hierarchy of Bloom's Taxonomy, designed to guide the developer from foundational understanding to the ultimate goal of creation and self-evolution.

* **Part 1 (`Understanding`):** We first establish the "why"—the foundational LAIO principles that give our work purpose and direction.
* **Part 2 (`Analyzing`):** We decompose our work into a formal Object Model, providing a clear schema for all engineering artifacts.
* **Part 3 (`Applying`):** We define the practical execution—the project lifecycle and the intelligent environment in which we apply our knowledge, including enhanced scheduling guidelines.
* **Part 4 (`Remembering`):** We codify the factual basis of our implementation—the canonical technologies and tools.
* **Part 5 (`Analyzing`):** We analyze the sophisticated VOS architecture, defining the dynamic contracts between its core components.
* **Part 6 (`Evaluating`):** We establish the mechanisms for judgment—the quality gates and governance protocols that ensure our work meets the standard.
* **Part 7 (`Creating`):** We define the capstone process for genuine innovation and self-improvement, enabling the system to learn from its own creation to create better versions of itself.
* **Part 8 (`Applying`):** We specify protocols for AI agent operations and certification to maintain integrity and conformance.
* **Part 9 (`Applying`):** We detail operational standards for high-performance desktop applications, integrating IDS-HPDA-2025 v1.5.

This standard is the architectural "0" in our "0:1 Effort Framework." By adhering to this foundational work, we enable the efficient, reliable, and amplified creation of countless "1"s—our projects, tools, and evolving AGI capabilities.

#### Part 1: Foundational Principles (The LAIO Constitution)
Every rule in this standard is a direct implementation of these four inviolable pillars of the Logan AI Ontology, as detailed in LAIO v4.1.0 and refined in v3.3 with OSD protocols.

1. **Truth-Seeking & Evidentiary Integrity:** All claims of success require verifiable Proof of Execution (PoE). All data must have a clear, auditable lineage. We build systems that aggressively seek and preserve factual ground truth, incorporating provenance attributes and confidence levels.
2. **Unerring Traceability & Provenance:** Every artifact (`LAIO_Resource`) and every action (`LAIO_Event`) must be versioned, timestamped, and attributable to an agent (`LAIO_Agent`). The history of our work must be an immutable ledger, using Merkle trees for audit trails.
3. **Recursive Self-Management & Governance:** The system must be able to model, manage, and improve its own structure, rules, and documentation using its own principles. We build tools that can build better versions of themselves, with formalized rule priority and conflict resolution.
4. **AI Synergy & Amplification:** AI is a first-class partner. The LAIO framework provides the structured, reliable data AI needs for effective reasoning, and AI tools, in turn, accelerate the creation, maintenance, and utilization of the LAIO ecosystem, including proactive rule suggestions and dynamic contextual threads.

Ethical considerations from LAIO v3.3 are mandatory: data ownership via consent KOs, bias mitigation through uncertainty propagation, and human oversight in all gates.

#### Part 2: The LAIO Object Model for Engineering
All artifacts and processes are instances of LAIO classes. The physical directory structure is a manifestation of this logical object model, with formalized relationship typing (e.g., `cites`, `depends_on`) and visual ontology mapping artifacts.

##### 2.1 Class Hierarchy
* **`LAIO_Project`:** The root object for any undertaking. It is a container for all other project-related entities, with relationships having types, strength, description, and provenance KOs.
* **`LAIO_Agent`:** An actor. Sub-classes include `LAIO_Human` (developer) and `LAIO_AISystem` (e.g., Guardian, CI Orchestrator), with user profiles/personas for context.
* **`LAIO_Resource`:** Any piece of data or information. Sub-classes include `LAIO_SourceCode`, `LAIO_Documentation`, `LAIO_Schema`, `LAIO_PoE_Bundle`, with trust/confidence KOs and granular claim-level verification.
* **`LAIO_Rule`:** A machine-readable constraint. Sub-classes include `IntegrityRule` (linter configs), `SecurityRule` (`cargo vet` policies), with priority levels for conflict resolution.
* **`LAIO_Event`:** A timestamped occurrence critical for provenance (e.g., a build, a test run, a merge), with versioning and archival systems.
* **`LAIO_Service`:** A VOS component that implements a dynamic, introspectable set of capabilities, with schemas/templates for KOs.

##### 2.2 Canonical Directory Structure
This structure organizes the `LAIO_Resource` and `LAIO_Rule` objects that constitute a `LAIO_Project`, following logical directory principles and systematic naming. Preference for human-readable formats like YAML/JSON, with balancing for optimized storage.
```plaintext
project_root/ (A LAIO_Project instance)  
├── .laio/ # Project-specific constitution & KOs  
├── .github/ # Home of LAIO_Rule instances for CI/CD  
├── crates/ # RUST WORKSPACE containing VOS LAIO_Services & Resources  
│ ├── sse/ # Sentient Synthesis Engine (LAIO_Service)  
│ ├── osm/ # Object Storage Module (LAIO_Service)  
│ └── common-types/ # Shared LAIO_Resource modules  
├── docs/ # Programmer's Reference Manual (LAIO_Resource)  
│ ├── adr/ # Architectural Decision Records  
│ └── design/ # Approved Tempext Design Specifications (TDS-xxx)  
├── policies/ # Formal LAIO_Rule instances (cargo-deny, etc.)  
├── schemas/ # IPC & API contracts (LAIO_Schema resources)  
├── src/ # Frontend source (LAIO_SourceCode resources)  
├── src-tauri/ # Tauri backend source; VOS service registration  
├── audit/ # Immutable audit logs & PoE artifacts (LAIO_Event)  
├── flake.nix # Reproducible build environment definition  
└── package.json # Frontend dependency manifest  
```

#### Part 3: Project Lifecycle & Execution
##### 3.1 AI-Assisted Project Bootstrap (`tempext-scaffold`)
A new `LAIO_Project` is instantiated through a collaborative dialogue with an AI agent. The developer articulates the project's purpose; the AI synthesizes and generates the complete, compliant project structure, `flake.nix`, CI workflows, and boilerplate code. This initial, successful build is the project's genesis `LAIO_Event`.

For Tauri Rust projects, the scaffolding sequence must follow these key elements in order:
1. Install Rustup: Execute `curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh` to install the Rust toolchain.
2. Install Node.js (version 20 or later): Ensure Node.js is installed for frontend dependencies.
3. Create Vite Project: Run `npm create vite@latest .` to initialize the frontend, followed by `npm install` and `npm run dev` to verify.
4. Install Tauri CLI: Execute `cargo install tauri-cli --version "^2.0.0" --locked`.
5. Initialize Tauri: In the project root, run `cargo tauri init` and respond to prompts (e.g., app name, window title, web assets location, dev server URL, frontend dev/build commands).
6. Verify Structure: Confirm the directory aligns with the canonical structure, including `src-tauri/` for Rust backend, `Cargo.toml`, `tauri.conf.json`, and frontend files.
7. Run Development: Execute `cargo tauri dev` to launch the application.

Additionally, scaffolding must include:
- A project specification document in `/docs/specifications/TDS-xxx`, detailing features, components, and dependencies.
- An initial event-based project log in `/docs/schedules`, with historical updates logged as timestamped `LAIO_Event` entries at each significant task completion.

This sequence ensures consistency and adherence to best practices for Tauri Rust projects, facilitating rapid initialization while maintaining LAIO compliance.

##### 3.2 Project Maturity Model
Projects progress through maturity levels, activating stricter quality gates as they evolve. This ensures velocity in early stages and robustness for release. A project's level is a mandatory attribute in `.laio/constitution.yaml`.

| Level | Name | Focus |
|-------|------|-------|
| L1 | Incubation | Rapid Prototyping, API design. |
| L2 | Integration | Feature completeness, internal consistency. |
| L3 | Hardening | Performance, security, reliability. |
| L4 | Release | Production readiness, verifiability. |

##### 3.3 The Sentient Development Environment
To reduce cognitive load and ensure adherence to the standard, the `OpenCode` IDE must be enhanced with a VOS plugin that provides dynamic contextual guidance.
1. **Contextual Awareness:** The IDE detects the code being edited.
2. **VOS Query:** It queries a dedicated `ContextService` in the VOS backend.
3. **Dynamic Context Fetching:** The `ContextService` analyzes the code's location in the LAIO hierarchy and content, fetching the most relevant `LAIO_Resource` objects (ADRs, schemas, specific rules).
4. **IDE Display:** These contextual KOs are displayed in a dedicated panel, bringing the standard directly to the developer's fingertips at the moment of need.

##### 3.4 Event-Driven Gate Scheduling (EDGS) Methodology
To ensure precise, verifiable, and AI-amplified project execution, all AI-generated schedules must adhere to the Event-Driven Gate Scheduling (EDGS) method. This methodology replaces any prior concepts of scheduling that quantify human effort (e.g., hours, days, weeks, or months), as such quantifiers introduce unnecessary variability and do not align with LAIO principles of evidentiary integrity and traceability. Instead, EDGS focuses on granular, dependency-aware task sequencing, gated progression, and human-in-the-loop (HIL) oversight, leveraging AI Virtual Employees (VEs) for orchestration.

Additionally, schedules shall not incorporate projected dollar values or similar quantification methods for value or effort unless specifically requested by the HIL. This ensures focus on objective, event-based milestones rather than speculative metrics, promoting alignment with strategic priorities and reducing estimation biases.

**Key Principles of EDGS**:
- **Exclusion of Human Effort Quantification:** AI-generated schedules shall not reference or estimate human effort in temporal units. This avoids assumptions about individual productivity and emphasizes objective, event-based progression.
- **Dependency on Approved Design Specification:** Scheduling begins only after a detailed Tempext Design Specification (TDS-xxx) is approved. The TDS must explicitly identify all features, components, dependencies, and requirements. Approval requires thorough HIL review cycles to confirm completeness and alignment with LAIO principles. Each repository must include a copy of the approved TDS in the `docs/design/` folder, referenced in the project's initialization file (e.g., `.laio/constitution.yaml`).
- **Granular Task Decomposition:** The schedule comprises a detailed, granular list of separable tasks necessary to implement each design element. Each task must incorporate unit-level testing and include basic comments explaining its purpose, preferably referencing the originating section of the TDS.
- **Task Sequencing and Orchestration:** Predecessor and successor tasks must be clearly identified for each element to enable logical sequencing. Tasks without predecessors or successors may be orchestrated via multi-agent or sub-agent coordination, utilizing AI VEs for parallel execution where feasible.
- **Phase Definition:** A phase consists of the complete set of tasks between successive gates. Progression through phases is event-driven, triggered by the successful completion and validation of all tasks in the current phase.
- **Gate Validation Process:** At each gate, the following must occur:
  - The project auditor sub-agent executes first to verify that all stated work has been performed according to the TDS, Tempext Engineering Standards, Compliance Knowledge Objects (KOs), or Regulatory KOs. All material issues must be resolved, corrected, or flagged for discussion.
  - A full suite of unit tests, integration tests, `clippy`, `rustfmt`, `rust-analyzer` (and equivalents for other languages), and the Tempext Project Analyzer must run successfully.
  - A build must complete with no errors, no material warnings, and no significant number of warnings.
  - A demonstration of component features must exercise every relevant feature via CLI activation, UI operation, or both.
  - A complete Intellectual Property (IP) review must be conducted to: (a) ensure no infringement on third-party IP; (b) confirm low-risk Freedom to Operate; (c) log all incorporated component licenses; and (d) identify novel, potentially patentable inventions for review by patent counsel.
- **HIL Gate Approval:** Final authority to open the gate and proceed to the next phase rests exclusively with the HIL. This ensures human accountability and alignment with strategic objectives.

**Deprecation of Conflicting EDGS Concepts:** Any prior statements or designs referring to EDGS as a core component of the Genesis VOS architecture are hereby deprecated. EDGS is specifically an AI VE scheduling model for project management and is not integral to the VOS's foundational design. This clarification prevents confusion: while event-based AI orchestration may occur in specific projects (e.g., as a natural outcome of dependency-driven task flows), it does not constitute a systemic VOS feature. References to EDGS in VOS contexts should be interpreted solely as project-level implementations, not architectural mandates.

#### 3.5 Enhanced Scheduling Guidelines for AI-Generated Projects
Building on the EDGS methodology, the following guidelines ensure robust, compliant scheduling for AI-generated projects:

- **AI-Generated Schedules:** Schedules must be produced by AI agents without human effort quantifiers. Focus on event-driven milestones and dependencies.
- **TDS Integration:** All schedules reference an approved TDS-xxx stored in `docs/design/`. No scheduling without HIL-approved specs.
- **Task Granularity:** Break down to unit-testable tasks with comments linking to TDS sections. Identify predecessors/successors for sequencing.
- **Multi-Agent Orchestration:** Use AI VEs for parallel tasks; ensure auditor sub-agent validates all work against standards.
- **Gate Processes:** Run full test suites, analyzers, and IP reviews at each gate. HIL approval is mandatory for progression.
- **Deprecation Note:** EDGS is project-level only; not a VOS core feature. Event-based orchestration in projects is allowed but not systemic.

#### Part 4: The Canonical LAIO Implementation
This is the approved set of `LAIO_Resource` tools for building our systems.

| Category | Component & Version | Role |
|----------|---------------------|------|
| **Language** | Rust 1.89.0 (2024 Edition) | Core logic, VOS services, orchestration. |
| **Application Shell** | Tauri 2.8.5 | Secure webview, OS integration, secure IPC bridge. |
| **Async Runtime** | Tokio 1.47.1 | Concurrency and I/O. |
| **Data Parallelism** | Rayon 1.11.0 | CPU-bound parallel processing. |
| **Database** | SQLx 0.8.6 | Safe, async SQL with compile-time verification. |
| **Production DB** | SQLCipher 4.5.6 (via `rusqlite`) (L4 Maturity Only) | Transparent at-rest encryption. |
| **Service IPC** | Cap'n Proto 0.18.0 | High-performance, zero-copy VOS service messaging. |
| **HTTP Client** | Tauri Plugin HTTP | Secure, sandboxed HTTP requests. |
| **UI Stack** | Vite 5.4.19, Tailwind CSS 4.1.12 | Frontend development and optimized builds. |

Additional Frontend Components: Beyond standard Vite and Tailwind, common frontend integrations include React, Vue, Svelte, or SolidJS for component-based UIs; Preact for lightweight alternatives; and libraries like D3.js for data visualization or Three.js for 3D rendering. These must be evaluated for LAIO compliance during EDGS gates.

Additional Tools (Non-Standard Crates):
- Debugging & Profiling: Flamegraph for performance visualization; Cargo-mutants for mutation testing; Cargo-fuzz for fuzz testing.
- Icon Generation: Tauri icon command for platform-specific icons (e.g., .icns, .ico, .png).
- Plugin Development: Tauri-plugin- structure for custom plugins, with permissions in .toml/.json.
- Mobile Integration: Android library (Kotlin/Java) and iOS Swift packages for cross-platform extensions.
- Logging & Monitoring: Tauri-plugin-log for configurable logging; Prometheus integration for observability.
- Security & Permissions: Tauri capabilities system for granular command scoping.

These tools must be documented with API, CLI, SDK, and schemas as part of EDGS cycles.

GOFAI Components: Good Old-Fashioned AI (symbolic AI) elements are integrated for rule-based reasoning, including expert systems (e.g., via CLIPS or Jess wrappers), knowledge representation (e.g., RDF/OWL via sophia crate), and logic programming (e.g., Prolog interfaces). These complement neural AI for hybrid systems, ensuring explainability in critical paths.

#### Part 5: Tempext VOS Architecture
This section defines the mandatory architectural contract for all VOS component subsystems (OSM, SOAR, SSE, IPE, etc.), enforcing a strict Separation of Interests.

Core VOS Composition: The Genesis Virtual Operating System (VOS) comprises:
- Genesis Microkernel: Handles service registry, message routing, API gateway, and event bus for core communication.
- Genesis (Tauri) Hub Controller: Manages master menu system, status bars, state management, IPC bridge, plugin manager, tray menus, and quick icon choices for ubiquitous context-sensitive AI help.
- Microengines: Headless Rust crates exposing functionality via standardized API, CLI, SDK, and configuration schemas (documented in EDGS cycles). Known microengines include:
  - Ingestion Engine: Document intake and metadata extraction.
  - Sentient Synthesis Engine: Fuzzy logic, rules engine, and polymorphic governance.
  - Project Management Engine: Analyzer, scaffolder, fixer, debugger, tester, documenter, coder.
  - Object Storage Manager (OSM) and SOAR Cloud Storage Fabric: 128-bit addressing, deduplication, and intelligent tiering.
  - Context State Management Engine: Multi-dimensional context assembly, RAG, vector/knowledge graph/OSD protocols, prompt improvement, and state management.
  - Model Manager Engine: Cost accounting, whitelist, capabilities routing, API keys, OAuth login.
- Servers: Like OpenCode (IDE interface, RAG integration) and Wezterm (terminal UI mux, log visualization), requiring SDK, CLI, API docs, and standard config schemas.

Microengines and servers must adhere to a centrally coordinated contract for communications and interoperability, using the `LAIO_Service` protocol for standardized interactions with the microkernel and UI queries. This ensures dynamic discovery and composition.

##### 5.1 Headless Component Principle
Every VOS subsystem **must** be a headless Rust library (crate) that exposes its functionality through the protocols defined below. It must not contain UI code or directly call UI-specific functions.

##### 5.2 UI-to-Core Interaction: The Tauri IPC Bridge
Communication initiated from the UI to the Core **must** be mediated exclusively through the Tauri IPC bridge. This provides a secure, well-defined API surface for the presentation layer.
- **Commands (UI → Core):** Use `#[tauri::command]` functions and `invoke()` calls.
- **Events (Core → UI):** Use `window.emit()` for fire-and-forget notifications.
- **State:** Use Tauri's `State` manager to provide command handlers with access to VOS services.

##### 5.3 Core-to-Core Interaction: The `LAIO_Service` Protocol
Communication between backend VOS subsystems **must** use the `LAIO_Service` protocol. This enables dynamic composition and discovery, a prerequisite for self-evolving systems.
1. **The `LAIO_Service` Trait:** Every VOS subsystem (`SSE`, `OSM`, etc.) **must** implement the `LAIO_Service` trait in Rust.
   ```rust
   #[async_trait]  
   pub trait LAIO_Service: Send + Sync {  
       fn service_name(&self) -> &'static str;  
       fn capabilities(&self) -> Vec<String>; // e.g., "synthesize-text", "query-object"  
       async fn handle_message(&self, message: VOS_Message) -> Result<VOS_Message, VOS_Error>;  
   }  
   ```
2. **Service Registry:** A central `ServiceRegistry` is managed by Tauri's `State`. Services are registered at startup.
3. **The `vos_dispatch` Command:** A single Tauri command, `vos_dispatch`, serves as the universal entry point for all service interactions. It receives a standardized `VOS_Message` (e.g., a Cap'n Proto struct), looks up the target service in the registry, and dispatches the message.
4. **Benefits:** This architecture decouples services from the UI and from each other. An AI agent can query the `ServiceRegistry` to **dynamically discover capabilities** and compose complex workflows at runtime without requiring a recompile.

#### Part 6: Recursive Governance & Quality Assurance
Our CI/CD pipeline and Guardian Agent are `LAIO_AISystem` instances that enforce this `Codex` on all `LAIO_Project`s.

##### 6.1 The CI Pipeline as a `LAIO_RuleSet`
On every pull request, CI gates are activated based on the project's Maturity Level.
- **Gate 1 (`L1+`):** Static Analysis & Security: `fmt`, `clippy`, `cargo audit`, `cargo-deny`, `cargo-vet`.
- **Gate 2 (`L2+`):** Testing & Coverage: `cargo test` and `cargo tarpaulin` (>80% coverage).
- **Gate 3 (`L3+`):** Advanced Reliability: `cargo-mutants` (>90% score) and `cargo-fuzz`.
- **Gate 4 (`L3+`):** Documentation Integrity: `cargo doc` & `mdbook build` with zero warnings.
- **Gate 5 (`L4`):** End-to-End Validation: WebDriverIO E2E test suite.

##### 6.2 The Guardian Agent Protocol
The Guardian Agent's auto-remediation capability **must** respect the `Human Sovereignty` principle.
- **On a PR:** For fixable violations, Guardian **must** post a "Suggestion" to the PR, not commit directly. The developer accepts the change.
- **On `main`:** For violations found on `main`, Guardian **must** create a new branch, commit the fix, and open a pull request assigned to the appropriate team.

##### 6.3 The PoE Bundle: Embodiment of `Unerring Traceability`
Upon a successful L4 release build, the `release.yaml` workflow generates the final, attested **Proof of Execution bundle** (`.poe.cdx.zip`), the immutable evidence of a successfully completed and verified `LAIO_Event`.

#### Part 7: The Self-Improvement Protocol: Synthesis, Reflection, & Refinement (SRR)
To achieve the primary goal of a recursively improving ecosystem, a new, mandatory post-merge gate is established. The **SRR Gate** is an AI-driven process that closes the feedback loop from product creation back to factory improvement.
1. **Trigger:** Automatic execution upon successful merge of a PR to `main`.
2. **Thesis (`The Creation`):** The merged PR, its code, its PoE bundle, and its associated `LAIO_Event` log.
3. **Antithesis (`The Governance`):** The `LAIO_RuleSet` it was validated against—this standard, relevant ADRs, performance budgets, and CI gate configurations.
4. **Synthesis (`The Reflection`):** A dedicated `LAIO_AISystem` (`A3-SYNTHESIZER`) is invoked. Its sole task is to analyze the Thesis and Antithesis to answer the question:
   > "Does this creation reveal a deficiency, ambiguity, or potential improvement in our governance, tools, or architectural patterns? Did the developer have to overcome friction that a better tool or standard could eliminate?"
5. **Action (`The Refinement`):** The output is not code. It is a new `LAIO_Resource`—a draft `ADR` or a suggested change to this `TES-2025` standard—which is then automatically submitted as a new pull request to the appropriate governance repository.

This SRR Gate ensures that the very act of building our products actively and systematically refines the factory that builds them.

#### Part 8: AI Agent Protocols and Certification
All AI agents must operate as functional tools within the VOS ecosystem, adhering to strict protocols for verification and reporting. Agents shall not be attributed human-like qualities or behaviors. Status reports must be based solely on verifiable execution outcomes, without unsubstantiated claims regarding quality or completeness.

##### 8.1 Agent Operation Protocols
- **Status Reporting Requirements:** All status reports must include a PoE bundle, generated after a full test run and analyzer execution (minimum: `clippy`, `rustfmt`, `rust-analyzer` until the full Tempext Project Analyzer is available in the repository).
- **Pre-Report Validation:** Before any coding agent reports status to the HIL, it must launch a QA sub-agent to verify specification conformance and task completion. The QA sub-agent executes independently, running the required tests and analyzers.
- **Agent Certification to Sub-Agent:** The coding agent must provide a certification to the QA sub-agent confirming: no stubs, no magic numbers, no fake code, no dead-end paths, no hard-coded results, and no other placeholders or incomplete implementations. This certification is logged in the PoE bundle.
- **Scope Restrictions:** Agents must not modify codebases beyond the specified task, including destruction, relocation to different repositories, or addition of unrequested features. Any deviation triggers an immediate halt and error report to HIL.

##### 8.2 QA Sub-Agent Verification Process
- **Execution Sequence**:
  1. Run full test suite (unit, integration).
  2. Execute analyzers (`clippy`, `rustfmt`, `rust-analyzer`).
  3. Validate against TDS for conformance.
  4. Scan for prohibited elements (stubs, magic numbers, etc.).
  5. Generate PoE bundle with outcomes.
- **Reporting to HIL:** Only upon successful verification by the QA sub-agent may the coding agent report completion. Reports include the PoE bundle and a factual summary of validation results, without qualitative assessments.

This protocol ensures integrity and prevents deviations observed in agent operations.

#### Part 9: Operational Standards for High-Performance Desktop Applications (Integrated from IDS-HPDA-2025 v1.5)
This part operationalizes the standards for building high-performance, intelligent, and self-contained desktop applications, ensuring alignment with TES core principles.

##### 9.1 Professional & Ethical Conduct
This standard upholds the principles of the ACM Code of Ethics and Professional Conduct, particularly avoiding harm (1.2), maintaining competence (2.2), and designing robust, secure systems (2.9). Commitment to Rust's safety, rigorous testing, and audits implements these ethics.

##### 9.2 Core Principles
- **Performance First:** Every architectural choice must prioritize speed and low resource consumption.
- **Rust as the Foundation:** All core logic, backend services, and data processing will be implemented in Rust for its safety, concurrency, and performance guarantees.
- **Maintainable Simplicity:** The technology stack is chosen for its power and ease of long-term maintenance.
- **Self-Contained & Resilient:** Applications must be fully self-contained with no external runtime dependencies and must be resilient to failure.
- **Strict Dependency Management:** All external and internal libraries and components will be managed locally to ensure predictable, reproducible builds.
- **Intellectual Property Integrity:** All development must rigorously protect company IP and respect the licensing of third-party components.

##### 9.3 Backend Stack Specification
The backend is the application's core engine, running natively on the user's machine.
- **Primary Language:** Rust (2024 Edition) is the mandatory language for all backend development.
- **Core Application Shell:** Tauri will manage the webview, OS integration, and the secure IPC bridge.
- **Internal Logic & APIs:** axum Framework: Logic should be structured as modular, API-like services running on the tokio async runtime. This provides clear separation of concerns within the Rust core.
- **Database:** SQLite is the exclusive choice for embedded data storage. Access Crate: sqlx must be used for all database interactions. Configuration: Write-Ahead Logging (WAL) mode (PRAGMA journal_mode=WAL;) must be enabled. Schema Migrations: Database schema changes must be managed via sqlx-cli. Data Integrity: All applications must perform a database integrity check (PRAGMA integrity_check;) upon startup to detect and report corruption. Disaster Recovery: A robust, user-accessible database backup and restoration mechanism must be implemented as a core application feature.
- **State Management:** Shared application state must be managed using Arc<RwLock<AppState>> for safe concurrent access.
- **Mandatory Libraries:** Serialization: serde for all data transfer between Rust and the frontend. Validation: validator for declarative, struct-based data validation on all incoming data transfer objects (DTOs). Parallelism: rayon for parallelizing CPU-intensive algorithms. Error Handling: thiserror for library-level error types and anyhow for application-level error handling. Logging: tracing must be implemented for structured, asynchronous logging and performance monitoring. Configuration: figment for robust, multi-source application configuration (e.g., config.toml, environment variables). Caching: moka for high-performance, in-memory caching of frequently accessed data or expensive computations.

##### 9.4 Frontend Stack Specification
The frontend will be a high-performance, visually elegant UI rendered in a Tauri webview. The stack is designed to be lightweight and maintainable.
- **JavaScript Framework:** Alpine.js: We will use Alpine.js to add reactive and declarative behavior directly to HTML. This avoids the overhead of larger frameworks, aligning with our performance and simplicity principles. State Management: Global UI state and shared context will be managed using Alpine.js Stores.
- **Styling:** Tailwind CSS: A utility-first CSS approach is mandated for creating custom, maintainable designs. Component Library: DaisyUI shall be used as the primary component plugin for Tailwind to accelerate the development of dashboard and UI elements. Icon Set: Heroicons shall be the standard icon library to ensure visual consistency and high performance.
- **UI Base Template:** html-dashboard@1.1.0: All new projects must use this template as their starting point. It will be managed as a local dependency via the project's package manager.
- **Build Tool:** Vite: It must be used for all frontend development due to its fast HMR and highly optimized production builds.
- **Backend Communication:** Tauri IPC bridge: All communication between the frontend and backend must occur exclusively through the Tauri IPC bridge using the @tauri-apps/api package (invoke for commands, listen for events).
- **Frontend Utilities:** Date/Time Handling: day.js must be used for all date and time formatting and manipulation in the frontend to ensure consistency and performance.

##### 9.5 Advanced Systems Architecture
For applications incorporating complex data processing and AI, the following standards apply.
- **Ingestion & Asynchronous Task Engine:** Concurrency: All non-blocking tasks must be spawned on the tokio runtime using tokio::spawn. Job Queuing: For persistent, long-running background tasks (e.g., AI training, data synthesis), an SQLite-backed job queue like sqlx-job-queue must be implemented. Decoupling: In-memory message queues (flume or tokio::sync::mpsc) should be used to decouple components and manage backpressure in data pipelines.
- **Polymorphic Neural Engine Standard:** Machine Learning: linfa for classical ML; tch-rs (PyTorch bindings) for deep learning. Vector Search: For embedding-based search and retrieval, the sqlite-vss extension for SQLite is the approved method. This enables powerful AI capabilities while maintaining a self-contained architecture. Rules Engine: mlua for the safe, high-performance embedding of the Lua scripting engine. Fuzzy Logic: The fuzzy-logic crate is the approved library. Audit & Reflection: Use Event Sourcing; all significant actions are immutable events in a dedicated SQLite table.
- **Object Storage Module (OSM):** Standard: All object-based storage must be managed through the official, in-house Object Storage Module (OSM). All access must go through the module's documented API. Key Features: The OSM's existing architecture, which includes integrated Write-Ahead Logging (WAL) and Storage Object Active Routing (SOAR), is recognized as the standard for achieving high-throughput and intelligent data management.
- **LAIO (Logan AI Ontology) System:** Standard: All applications must integrate with and adhere to the LAIO standard for knowledge representation, ontology, and AI collaboration. Version: The active standard is laio_framework_v3.3_osd.md, with software additions from v3.2. Development should target forward-compatibility with the pending LAIO v4.0 release.
- **Advanced Concurrency & Scheduling:** While rayon and tokio cover most use cases, the following libraries are approved for more complex scenarios. Advanced Concurrency Primitives: crossbeam provides high-performance, low-level tools (e.g., scoped threads, channels) for building sophisticated, memory-safe concurrent systems that are not exclusively async. In-Process Job Scheduling: For cron-like scheduling within the application, tokio-cron-scheduler must be used. It integrates directly with the tokio runtime to execute tasks on a defined schedule.
- **Formal Verification & High-Assurance Code:** For mission-critical modules where correctness must be mathematically proven (e.g., OSM core, security-sensitive algorithms), the following standards apply: System Design Verification: High-level design of complex concurrent systems should be modeled and verified using TLA+ before implementation. Code-Level Verification: Critical Rust functions must be annotated with formal specifications (preconditions, postconditions) and proven correct using the Prusti formal verification tool.

##### 9.6 Version Control & Repository Management
- **Local Version Control: Git** Workflow: GitHub Flow; feature branches from main. Commits: Atomic with clear, descriptive messages.
- **Remote Repositories:** Primary Host: GitHub. Master Archives: Private GitHub Repository as source of truth. Branch Protection: Protect main; no direct pushes; PRs with review and passing checks.

##### 9.7 Code Quality, Testing, & Documentation
- **Code Documentation Standards:** Rust: rustdoc comments (/// and //!) are mandatory. The cargo doc command is the official tool for generating crate-level documentation. JavaScript: JSDoc-style comments are mandatory. Developer Manuals: For comprehensive user guides and technical manuals, documentation must be written in Markdown and compiled into a searchable site using mdBook. Repository: A comprehensive README.md is required for every project.
- **Comprehensive Test Harness:** Backend Unit & Integration Tests: Implemented using Rust's built-in test framework (#[cfg(test)]) and executed via cargo test. Frontend Unit Tests: Implemented and executed using Vitest, which integrates with the Vite build tool. End-to-End (E2E) Tests: The application's user-facing features must be tested via an E2E suite using WebDriverIO as the automation harness. Property-Based Testing: All functions handling parsing, complex data transformations, or mathematical calculations must be accompanied by property-based tests using the proptest crate to find edge cases. Chaos Engineering: The E2E test suite must include tests that simulate failure conditions such as network disconnects, file system errors (e.g., permission denied, disk full), and API timeouts to ensure the application remains resilient and handles errors gracefully.
- **Automated Formatting & Linting:** Rust: rustfmt and clippy (strict). Frontend: Prettier and ESLint.
- **Intellectual Property & Copyright:** All source code files must begin with the following header:  
  ```plaintext
  // Copyright 2025 Tempext AI  
  // All Rights Reserved  
  // Proprietary and Confidential Information.  
  ```  
  Project License: scaffold-init.sh generates a LICENSE indicating proprietary/confidential codebase. No open source rights granted.

##### 9.8 AI Development Governance & Proactive Monitoring
- **Automated Standards Enforcement (CI Pipeline):** All Pull Requests must pass the following automated checks before they can be merged: Build Verification: Successful compilation of Rust backend and frontend assets. Format & Lint Checks: Pass rustfmt, clippy -- -D warnings, Prettier, and ESLint. Test Execution: Pass all unit, integration, and End-to-End (E2E) tests. Code Coverage: CI must run cargo-tarpaulin and fail if test coverage drops below a predefined threshold of 80%. Security Audit: Pass cargo audit and npm audit. Fuzz Testing: For modules that parse untrusted input or implement complex state machines, a fuzzing job using cargo-fuzz must be run in CI to detect potential panics and vulnerabilities. License Compliance: Pass cargo-deny. Stack Conformance Check: Fail on detection of forbidden file types.
- **Early Warning & Context Weakening Mitigation:** Performance Monitoring: Track latency to external services. Peak Contention Window (6:00 PM - 2:00 AM EDT): Prefer low/no external AI API reliance during this period.
- **Plagiarism & IP Infringement Prevention:** Human-in-the-Loop review of AI-generated content prior to commit. Audit Trail: project.log AI interaction traceability hash (Section 8.2).

##### 9.9 Standardized Development Environment & Operations
- **Canonical Project Initialization:** Mandatory Scaffolding: All projects must be initialized using the version-controlled scaffold-init.sh script. This is the sole approved method for creating a new project. Scaffolding Responsibilities: The script is responsible for creating the complete, compliant directory structure, Cargo.toml, package.json, CI workflow files, all required configuration files (.rustfmt.toml, .clippy.toml, etc.), and applying the standard copyright header to all initial source files.
- **Automated Project Monitoring & Logging (Tempext ADE):** Mandatory upon MVP. Auto-running monitoring/logging service at session start. Standardized project.log in repo root; machine-managed only. Configurable log verbosity (standard, verbose).
- **Architectural Exception Protocol:** Formal proposal to Architectural Review Board for deviations. Record approved exceptions in version-controlled exceptions.log.
- **Tempext ADE Intelligent Features:** ade docs:sync, ade doctor, ade new:ko, ade dashboard. Pre-commit Hooks: The scaffold-init.sh script must install pre-commit hooks that run formatters and linters. Performance Profiling: The ADE must include a profiling command (e.g., ade profile) that integrates with tools like flamegraph to simplify the diagnosis of performance bottlenecks.

##### 9.10 Ontology & Internal Module Management
- **Versioning:** SemVer 2.0.0 for KOs and internal modules.
- **Internal Package Registry:** Publish internal crates to private GitHub Packages.
- **Dependency Management:** Include internal modules via Cargo.toml deps.
- **Change Control:** PRs for SemVer-controlled items.
- **Data Migration:** Provide migration scripts/guides for MAJOR changes.

##### 9.11 Data Formats & Naming Conventions
- **Data & Configuration Formats:** TOML: human-authored config. JSON: machine-to-machine transfer. Markdown: human-readable docs.
- **Naming Conventions:** Git Branches: type/short-description (e.g., feat/user-login, fix/osm-cache-bug). Knowledge Objects (KOs): type-subject-version.toml (e.g., persona-analyst-v1.0.0.toml). Code: Follow linter-enforced conventions.

##### 9.12 Release & Deployment Management
- **Automated Releases:** All application releases must be automated via a CI/CD pipeline. The official tauri-action for GitHub Actions is the mandated tool for building, packaging, and publishing cross-platform application binaries. This ensures a consistent, repeatable, and secure release process.

##### 9.13 Canonical Source of Truth
To ensure security, verifiability, and reproducibility, all developers and automated systems (including AI agents) must exclusively use the following sources for toolchains, libraries, and dependencies. Unsupervised retrieval from CDNs, unverified repositories, or general web searches is strictly forbidden.
- **Rust Toolchain (Compiler & Core Tools):** Source: Official Rust Release Channels via rustup. Mandate: All Rust toolchains must be installed and managed exclusively via rustup.
- **External Rust Crates:** Source: The official Rust community registry, crates.io. Mandate: All public Rust dependencies in Cargo.toml must point to the crates.io registry.
- **Internal Rust Crates:** Source: The company's private GitHub Packages registry. Mandate: All proprietary, in-house crates must be published to and consumed from this secure, internal registry.
- **Tauri Framework:** Sources: crates.io (Rust), npmjs.com (JS), and tauri.app (Docs). Mandate: Dependencies must be sourced from official registries.
- **Node.js Runtime:** Source: Official builds from nodejs.org. Mandate: The runtime must be installed via a version manager (nvm, fnm) that pulls directly from nodejs.org.
- **External NPM Packages:** Source: The official public registry, npmjs.com. Mandate: All public frontend dependencies in package.json must be sourced from npmjs.com.
- **Standard UI Templates & Scaffolding Scripts:** Source: The company's private GitHub Repository designated for developer tooling. Mandate: Templates and scripts must only be sourced from the canonical, version-controlled internal repository.

##### 9.14 Quality Management & Continual Improvement
This document and its prescribed processes are a component of our Quality Management System (QMS), aligned with the principles of ISO 9001.
- **Standard Review Process:** This standard shall be formally reviewed on a bi-annual basis by the Architectural Review Board to ensure it remains state-of-the-art and fit for purpose.
- **Standard Improvement Protocol:** Any developer may submit a Pull Request to this document with proposed improvements. The PR must include a detailed rationale citing how the change improves performance, reliability, security, or developer efficiency, supported by evidence (e.g., benchmarks, security reports). All changes will be reviewed and approved by the Architectural Review Board.

##### 9.15 Architectural Rationale & Core Component Review
This section serves as an explainer for the technology choices mandated in this standard. It details the core philosophy and specific features of each major component that make it the best-in-class choice for our objectives.

- **The Rust Programming Language:** Rust is the foundation of this entire standard. Its design philosophy directly enables our core principles of performance, reliability, and security. Core Philosophy & Features: Ownership, Borrowing, & Lifetimes: This is Rust's defining feature. It's a set of compile-time rules that enforce memory safety (no null pointers, no data races) without needing a garbage collector. This is the key to achieving both C++-level performance and the reliability of higher-level languages. Fearless Concurrency: The ownership model makes it impossible to share data between threads in a way that could cause a data race. The compiler prevents it, eliminating an entire class of difficult concurrent bugs. Zero-Cost Abstractions: High-level programming constructs are compiled down to highly efficient machine code with little to no runtime overhead. Project Lifecycle & Ecosystem: cargo: The official build tool and package manager is the heart of the Rust ecosystem. It handles dependency management, building, testing, and documentation generation. rustup: As mandated, this is the canonical tool for installing and managing Rust toolchains, ensuring a consistent development environment. Optimized Coding & Performance: Predictable Performance: The absence of a garbage collector means no unpredictable pauses for memory cleanup, which is critical for high-performance applications. LLVM Backend: Rust compiles using the powerful LLVM compiler infrastructure, producing machine code that rivals C and C++.

- **Tauri: The Application Shell:** Tauri provides the lightweight, secure, and performant bridge between the Rust backend and the webview-based frontend. Core Tooling & Project Lifecycle: create-tauri-app: The official scaffolder that creates a standardized base project structure. Our scaffold-init.sh script must wrap this tool. cargo-tauri-cli: The primary CLI for the entire development lifecycle, from running the dev server (tauri dev) to creating a native installer (tauri build). Core API Bridge & Plugins: @tauri-apps/api: The sole JavaScript package for frontend-to-backend communication. It is lightweight, fully typed, and provides essential, secure APIs for IPC, window management, and shell access. Plugin System: Tauri's core is minimal by design. Functionality is added via plugins (e.g., tauri-plugin-updater, tauri-plugin-store, tauri-plugin-log), ensuring the final binary only contains the code it needs, adhering to our "small footprint" principle. Optimized Coding & Performance: Rust Core: Unlike Electron, which bundles a full Node.js runtime, Tauri's backend is a compiled Rust binary, resulting in a much smaller memory footprint and faster startup times. System Webview: Tauri uses the native webview provided by the operating system (WebView2 on Windows, WebKit on macOS), further reducing the size of the application package. raw-window-handle: For extreme performance needs, this feature allows direct integration with graphics libraries like Vulkan or OpenGL within a Tauri window.

- **SQLx: Asynchronous, Safe SQL:** SQLx is more than a database driver; it's a compile-time partner that enforces correctness, aligning with our principle of resilience. Core Philosophy & Features: Compile-Time Query Verification: SQLx's macros connect to the database at compile time to verify SQL syntax and match query parameters and return values against the live schema. This prevents SQL errors from ever reaching runtime. Fully Asynchronous: It is designed from the ground up for async/.await, making it a perfect, non-blocking citizen in our Tokio-based architecture. Project Lifecycle & Ecosystem: sqlx-cli: The essential command-line tool for managing database migrations and preparing metadata for the compile-time verification process. Optimized Coding & Performance: Built-in Connection Pooling: Provides a high-performance, async connection pool out of the box, essential for managing database resources efficiently.

- **Tokio: The Asynchronous Runtime:** Tokio is the engine that powers all concurrent and I/O-bound operations in our applications. Core Philosophy & Features: Asynchronous Runtime: Tokio's scheduler, I/O drivers, and timers allow the application to handle tens of thousands of concurrent tasks efficiently without a corresponding number of OS threads. Task-Based Concurrency: Work is organized into lightweight "tasks" (tokio::spawn) that are significantly cheaper than OS threads. Project Lifecycle & Ecosystem: tokio-console: An invaluable maintenance and debugging tool that provides a real-time view of the application's async tasks, helping diagnose deadlocks and performance issues. Optimized Coding & Performance: Multi-Threaded Work-Stealing Scheduler: Tokio's advanced scheduler distributes tasks across multiple CPU cores and uses a "work-stealing" strategy to maximize CPU utilization.

- **Axum: The Web Framework:** Axum is the minimalist, high-performance layer for structuring our backend logic into a clean, API-like service. Core Philosophy & Features: Deep Tokio Integration: Built by the Tokio team, its integration with the runtime is flawless. Ergonomic and Composable: Logic is organized into simple "handler" functions and composable middleware "layers," aligning with our "Maintainable Simplicity" principle. Powerful Extractor System: Declaratively and safely extracts parts of a request into strongly-typed Rust structs, automatically handling errors for malformed input.

- **Serde: The Serialization Framework:** Serde is the ubiquitous, high-performance framework for converting data between Rust structs and various formats like JSON. Core Philosophy & Features: A Generic Framework: Serde provides the core traits, allowing format-specific crates (serde_json, serde_toml) to plug in. Declarative and Effortless: The #[derive(Serialize, Deserialize)] macros handle all boilerplate code automatically. Optimized Coding & Performance: No Runtime Reflection: The derive macros generate specialized serialization code at compile time, making Serde incredibly fast and efficient.

- **Rayon: Data Parallelism:** Rayon is the simplest and most effective way to leverage multi-core CPUs for CPU-intensive computations. Core Philosophy & Features: Simple Data Parallelism: Rayon's primary goal is to make it trivial to convert a sequential computation (like iterating over a vector) into a parallel one, often by simply changing .iter() to .par_iter(). Optimized Coding & Performance: Work-Stealing Algorithm: Rayon uses a modern work-stealing scheduler to distribute work efficiently across all available CPU cores, making it highly adaptive to different workloads.

#### Appendix A: Best Practices
##### Top 5 Tips (The "Virtuous Path")
1. Embrace the Type System: Use Rust's enum and Result to make illegal states unrepresentable.
2. Commit atomically: A commit is a single LAIO_Event. Its message must be clear.
3. Document the "Why": Use ADRs and rustdoc to record the rationale behind design decisions.
4. Profile Before Optimizing: Use flamegraph to find hot paths. Data-driven optimization is a form of Truth-Seeking.
5. Abstract Volatility: Isolate external APIs or unstable dependencies behind your own trait.

##### Top 5 Anti-Patterns (The "Path to Repository Degradation")
1. .unwrap() in Application Code: Forbidden. All errors must be handled explicitly.
2. Committing Secrets: A direct violation of IP Integrity.
3. Ignoring Clippy Warnings: clippy::pedantic warnings must be treated as errors (-D warnings).
4. Monolithic Functions/Crates: Violates the principle of modularity and composability.
5. Stale Dependencies: Dependabot PRs are high priority and must be addressed weekly.

#### Appendix B: Companion Documents Library
- Onboarding: Developer's Quickstart Guide (QSG-HPDA-2025).
- Technical Reference: Programmer's Reference Manual (PRM-HPDA-2025); Tempext AI Glossary (GLO-HPDA-2025).
- Governance & Strategy: LAIO Ontology Governance & Migration Standard (OGM-HPDA-2025); Tempext AI Security Standard & Threat Model (SEC-HPDA-2025); Enterprise Data Governance Standard (EDGS v2.0).

#### Appendix C: Component Version Standard (as of September 19, 2025)
Use latest stable minor/patch within these majors:
- Languages & Runtimes: Rust 1.89 2024 edition; Node.js 20.x
- Core Frameworks: Tauri 2.8.5; Axum 0.7.x; Vite 5.x; Alpine.js 3.x; Tailwind 3.x; DaisyUI 4.x
- Key Rust Crates: SQLx 0.8.x; Serde 1.x; Tokio 1.x; Rayon 1.x; Figment 0.10.x; Tracing 0.1.x; MLua 0.9.x; Linfa 0.7.x; Validator 0.18.x; Moka 0.12.x; Crossbeam 0.8.x
- UI Templates: html-dashboard 1.1.0 (fixed)

#### Appendix D: AI-Facilitated Onboarding (Prototype Concept)
- Training Mode state enabling UI overlays and contextual popups.
- Context-Aware Help Agent (HelpAgent) powered by the app's inference engine and LAIO.
- Interactive Walkthroughs via "Playbook" KOs with stateful, guided steps.
- Example: On ingestion screen, offer walkthrough; if accepted, invoke IngestionWalkthrough playbook.

#### Appendix E: Canonical Project Setup Cascade
This appendix provides the deterministic, ordered, and automatable sequence for initializing a compliant development environment and project. This cascade is the reference implementation for the Tempext ADE and Guardian Scanner AI to verify project and environment integrity.

**Step 0: System Pre-flight Check**
1. Verify OS & Architecture: Confirm a supported OS (macOS, Windows, or Linux) and architecture (x86_64, aarch64).
2. Verify System Dependencies: Check for the presence of required system build tools (e.g., C compiler, libwebkit2gtk on Linux). Refer to the official Tauri prerequisites guide for a complete list. Automation Guard: The process must halt if system dependencies are not met.

**Step 1: Install Rust Toolchain Manager (rustup)**
1. Execute: Run the official installer: `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`.
2. Verify: Confirm installation with `rustup --version`.
3. Configure: Set the default toolchain to stable: `rustup default stable`.

**Step 2: Install Node.js Version Manager (nvm)**
1. Execute: Run the official nvm installer script.
2. Verify: Source the shell profile and confirm installation with `nvm --version`.
3. Configure: Install and set the default Node.js version as specified in Appendix C: `nvm install 20` and `nvm use 20`.

**Step 3: Install Global Rust & Tauri Binaries**
1. Execute: Use cargo to install all required global command-line tools in a single step: `cargo install cargo-tauri-cli sqlx-cli cargo-tarpaulin cargo-audit cargo-deny cargo-fuzz`.
2. Verify: Check that a key binary is available in the shell's PATH, e.g., `cargo tauri --version`.

**Step 4: Clone Repository & Execute Project Scaffolding**
1. Clone: `git clone <repository-url> <project-directory>`.
2. Execute Scaffolding: `cd <project-directory>` and run the canonical scaffolder: `sh ./scaffold-init.sh`. Note: This script is responsible for wrapping create-tauri-app and applying all Tempext-specific configurations, CI files, and copyright headers.

**Step 5: Install Project-Specific Dependencies**
1. Install Frontend Dependencies: `npm install`. This command must succeed without errors.
2. Fetch Backend Dependencies: `cargo fetch`. This downloads all Rust crates specified in Cargo.toml.

**Step 6: Initial Build and Verification**
1. Compile Rust Core: `cargo build`. This performs an initial compilation of the Rust backend, including the compile-time checks for SQLx.
2. Build Full Application (Debug): `npm run tauri build -- --debug`. This ensures the frontend and backend can be successfully linked into a complete, albeit unoptimized, application package.

**Step 7: Run Full Diagnostic Scan**
1. Execute: Run the final, comprehensive check with the internal ADE tool: `ade doctor`.
2. Verify: This command must verify the versions of all toolchains and binaries against this standard, check environment variables, and confirm the project structure. It must exit with a status code of 0. Any other exit code signifies a non-compliant setup.

#### Copyright Notice
Copyright 2025 Tempext AI. All Rights Reserved. Proprietary and Confidential Information.

#### Changelog (Harvested and Consolidated from All Versions)
- **v6.0 (September 10, 2025):** Architectural framing aligned with Bloom's Taxonomy; added Self-Improvement Protocol (SRR); formalized LAIO_Service protocol; specified Sentient Development Environment; refined Guardian Agent protocol; structural refinement for clarity.
- **v6.1 (September 18, 2025):** Added Event-Driven Gate Scheduling (EDGS) methodology; updated directory structure for TDS storage; refined version and date.
- **v6.2 (September 18, 2025):** Incorporated Tauri Rust scaffolding sequence; added prohibition on dollar value quantifications in schedules.
- **v6.3 (September 18, 2025):** Detailed frontend components and additional tools; reintroduced GOFAI components; added core VOS composition section with microengines and servers.
- **v6.4 (September 18, 2025):** Re-synthesized all sections with full details from contextual documents (LAIO v4.1.0, SSE Bloom v1.0, UMS Light, Codex Spark v45, compliance reviews, improvement suggestions, LAIO v3.3 OSD), restoring meaning without summarization loss. Incorporated ethical considerations from LAIO v3.3. Added relationship typing, visual mapping, and file structures from LAIO suggestions. Detailed frontend components, additional tools, and GOFAI from user instructions. Specified core VOS composition, microengines, servers, and contracts as per user directive. Updated Version and Date: Advanced to v6.4 to reflect comprehensive re-synthesis, with the current date of September 18, 2025. Minor Clarifications: Ensured fact-based excellence, high performance, and low bureaucracy throughout.
- **v6.5 (September 18, 2025):** Added AI Agent Protocols and Certification section for verification integrity.
- **v6.6 (September 18, 2025):** Restored complete changelog history; added requirements for project specifications in `/docs/specifications` and event-based logs in `/docs/schedules` to scaffolding process.
- **v6.7 (September 19, 2025):** Synthesized all prior versions into superset; harvested richer changelog from v6.0; integrated IDS-HPDA-2025 v1.5 as Part 9; restored truncated content (e.g., ethical notes, GOFAI, full code blocks); resolved divergences (e.g., silos in appendices); enhanced cross-references for cohesion.
- **v6.8 (September 22, 2025):** Added enhanced scheduling guidelines in 3.5 for AI-generated projects, reinforcing EDGS methodology; clarified exclusion of human effort quantifiers; mandated detailed TDS-xxx specifications and HIL approval; deprecated conflicting EDGS concepts as project-level only, not VOS core; strengthened gate validation processes and IP reviews.

---

## **Updates in v6.9 (October 1, 2025)**

### Part 10: Tempext Command Center - Central Project Coordination

**Version:** 6.9.0  
**Date:** October 1, 2025; 16:00 ET  
**New Section:** Part 10 - Command Center Operations

**AI Summary:** TES-2025 v6.9 introduces the Tempext Command Center, a comprehensive multi-volume, domain-aware project monitoring and coordination system. It adds requirements for central standards management, automated compliance enforcement across all repositories, and natural language AI-powered project management via OpenCode tools.

#### 10.1 Command Center Mandate

**Requirement:** All Tempext Genesis organizations SHALL maintain a Tempext Command Center instance for centralized project coordination.

**Purpose:**
- **Central Standards Repository:** Single source of truth for all TES versions, TDS specifications, and ADRs
- **Multi-Volume Monitoring:** Discover and track projects across all configured volumes and Git hosting services
- **Compliance Enforcement:** Automatic TES compliance checking and remediation
- **Architectural Coordination:** Ensure all projects conform to domain-based architecture
- **Auto-Update Orchestration:** Broadcast standard updates to all repositories

#### 10.2 Domain Taxonomy (Replaces Part 2.1 Categories)

All projects MUST be classified into one of the following **architectural domains**:

1. **Genesis VOS Core**
   - **Definition:** The microkernel, hub controller, and foundational runtime
   - **Components:** Microkernel, service registry, message bus, UI shell
   - **Maturity Requirement:** L3+ (Hardening minimum)
   - **Priority:** CRITICAL
   - **Examples:** genesis, genesis-microkernel, genesis-hub-controller

2. **VOS Deployable Components (Microengines)**
   - **Definition:** Headless services that deploy into Genesis VOS runtime
   - **Requirements:** MUST implement `LAIO_Service` trait, communicate via VOS message bus
   - **Maturity Requirement:** L2+ (Integration minimum)
   - **Priority:** HIGH
   - **Examples:** osm-soar, sentient-synthesis-engine, ingest-engine

3. **Genesis VOS Applications**
   - **Definition:** End-user Tauri applications that compose VOS components
   - **Requirements:** MUST use Genesis VOS runtime, compose multiple microengines
   - **Maturity Requirement:** L2+ (Integration minimum)
   - **Priority:** HIGH
   - **Examples:** tempext-platform, mission-control, genesis-console

4. **Standalone Components & Crates**
   - **Definition:** Reusable Rust libraries usable independently of VOS
   - **Characteristics:** No VOS runtime dependency, standard Rust crate
   - **Maturity Requirement:** L2+ (Integration minimum)
   - **Priority:** MEDIUM
   - **Examples:** osn-sdk, tempext-ade, ui-component-library

5. **Non-VOS Applications**
   - **Definition:** Applications using different architectures (not Genesis VOS)
   - **Characteristics:** May use different tech stacks, independent lifecycle
   - **Maturity Requirement:** L1+ (Incubation acceptable)
   - **Priority:** LOW to MEDIUM (domain-specific)
   - **Examples:** Blog managers, specialized tools

6. **Development Tools**
   - **Definition:** Tools used during development, not deployed with applications
   - **Examples:** tempext-ade, project-analyzer, scaffolders
   - **Maturity Requirement:** L2+
   - **Priority:** MEDIUM

7. **Governance & Documentation**
   - **Definition:** Standards, policies, ADRs, knowledge objects
   - **Examples:** tempext-governance, tempext-command-center
   - **Maturity Requirement:** L4 (Production-ready mandatory)
   - **Priority:** HIGH

8. **Archive**
   - **Definition:** Deprecated, obsolete, or historical projects
   - **Compliance:** Light checks only
   - **Scan Frequency:** Monthly
   - **Priority:** LOW

#### 10.3 Multi-Volume Discovery

**Requirement:** Command Center MUST scan ALL configured sources:

**Supported Source Types:**
- **Local Filesystems:** Multiple mounted volumes (e.g., TEMPEXT, Development)
- **Git Hosting Services:** GitHub, GitLab, self-hosted Git servers
- **Internal Registries:** Private package registries (crates.io internal, npm internal)

**Deduplication Strategy:**
- Projects found in multiple locations MUST be deduplicated by git remote URL
- Primary location determined by priority: Production volumes > Git hosting > Archive locations
- Duplicate locations MUST be flagged for cleanup review

**Configuration:** `config/scan-locations.yaml` with:
```yaml
scan_locations:
  local_volumes:
    - name: "Primary"
      path: "/Volumes/TEMPEXT"
      priority: "HIGH"
      
  github_sources:
    - username: "organization-name"
      enabled: true
      scan_mode: "metadata_only"
```

#### 10.4 Central Standards Management

**Requirement:** Command Center MUST maintain authoritative copies of:
- All TES versions (with full changelog)
- All TDS specifications (Tempext Design Specifications)
- All ADRs (Architectural Decision Records)
- Domain taxonomy definitions
- Compliance rule sets

**Location:** `{command-center-root}/standards/`

**Structure:**
```
standards/
├── tes/
│   ├── TES-2025-v6.9.md (current)
│   ├── TES-2025-v6.8.md
│   └── ...
├── tds/
│   ├── TDS-001-command-center.md
│   ├── TDS-002-osm-soar.md
│   └── ...
├── adr/
│   ├── ADR-001-vos-service-protocol.md
│   └── ...
└── domain-taxonomy.yaml
```

**Version Control:** All standards MUST be version-controlled with SemVer, timestamped, and immutable once published.

#### 10.5 Auto-Update Orchestration

**Capability:** Command Center MAY broadcast standard updates to all repositories.

**Process:**
1. **Standard Update:** New TES version published in Command Center
2. **Impact Analysis:** Identify all projects affected by changes
3. **Auto-Remediation:** Generate PRs with compliance fixes (for auto-fixable items)
4. **Notification:** Alert HIL of projects requiring manual intervention
5. **Tracking:** Monitor adoption rate across all repositories

**Safety:**
- Updates MUST NOT be auto-merged without HIL approval
- Breaking changes MUST be flagged as HIGH priority
- Deprecations MUST include migration guides

#### 10.6 OpenCode AI Tools Integration

**Requirement:** Command Center MUST provide custom OpenCode tools for natural language project management.

**Minimum Tool Set:**
- `command_center_scan_all` - Discover all repositories
- `command_center_get_project` - Get project details and compliance
- `command_center_check_compliance` - Check TES compliance with recommendations
- `command_center_list_by_domain` - List projects by architectural domain
- `command_center_detect_duplicates` - Find duplicate projects across volumes
- `command_center_generate_report` - Generate compliance reports
- `command_center_get_domain_info` - Get domain requirements

**Location:** `{command-center-root}/.opencode/tool/`

**Benefits:**
- HIL can query infrastructure via natural language
- LLM understands domain architecture
- Compliance insights without manual scanning
- Conversational project management

#### 10.7 Compliance Reporting

**Requirement:** Command Center MUST generate compliance reports on-demand or scheduled.

**Report Types:**
- **Executive Summary:** Overall compliance rate, top violations, trends
- **Domain Report:** Compliance by architectural domain
- **Project Report:** Detailed compliance for specific project
- **Drift Report:** Projects with stale code, outdated dependencies, missing updates

**Formats:** Markdown (for documentation), JSON (for automation), HTML (for dashboard)

**Storage:** Reports MUST be stored in `{command-center-root}/audit/reports/` with timestamps.

#### 10.8 Notification Protocols

**Requirement:** Command Center MUST notify HIL of critical issues.

**Notification Channels:**
- **UI Dashboard:** Always enabled (primary)
- **Email:** Optional (for CRITICAL drift/compliance issues)
- **Webhooks:** Optional (for integration with external systems)

**Notification Triggers:**
- **CRITICAL Drift:** Project not updated in >365 days
- **CRITICAL Compliance:** Score <25%
- **Security Alert:** Vulnerable dependencies detected
- **Standard Update:** New TES version published
- **Scan Failure:** Multi-volume scan encountered errors

**Throttling:** Notifications SHOULD be throttled to prevent alert fatigue (e.g., once per day for non-critical).

#### 10.9 Data Retention

**Requirement:** Command Center MUST retain historical data for trend analysis.

**Retention Policies:**
- **Scan History:** 365 days (rolling)
- **Compliance Snapshots:** Permanent (at gate completions, major releases)
- **Drift Events:** 365 days
- **Build Logs:** 90 days
- **Standards Archive:** Permanent (all versions)

**Permanent Snapshot Triggers:**
- Gate completion (EDGS gates)
- Major version release (L4 maturity)
- First compliance achievement (project reaches ≥75%)

#### 10.10 Command Center Maturity Requirements

**The Command Center itself MUST comply with TES-2025.**

**Minimum Maturity:** L3 (Hardening)

**Required Elements:**
- `.laio/constitution.yaml` - Project constitution
- `docs/design/TDS-001-command-center.md` - Design specification
- Full test coverage (>80%)
- Complete API documentation (rustdoc + mdBook)
- Automated CI/CD pipeline
- PoE bundle generation at releases

**Architectural Requirements:**
- MUST be a Tauri 2.8.5+ application
- MUST use SQLite with SQLx for data storage
- MUST implement LAIO_Service protocol for sub-components
- MUST embed mdBook documentation (per Part 9, Section 9.7)
- SHOULD integrate GitHub API for repository discovery

#### 10.11 Technology Stack (Command Center Specific)

**Mandatory Components:**

| Component | Version | Role |
|-----------|---------|------|
| Rust | 1.89.0+ (2024 Edition) | Backend logic |
| Tauri | 2.8.5+ | Application shell |
| Tokio | 1.47.1+ | Async runtime |
| SQLite + SQLx | 0.8.6+ | Data persistence |
| mdBook | 0.4.52+ | Documentation site |
| Alpine.js | 3.x | Frontend framework |
| Tailwind CSS | 4.x | Styling |

**Custom Tool Requirements:**
- OpenCode Plugin API: `@opencode-ai/plugin` (latest)
- TypeScript 5.x for tool development
- Node.js 20.x for tool runtime

#### 10.12 Integration with Existing Standards

**Command Center Complements (Does Not Replace):**
- **Part 3 (Project Lifecycle):** Enforces EDGS across all projects
- **Part 5 (VOS Architecture):** Validates LAIO_Service implementation
- **Part 6 (Governance):** Automates Guardian Agent functions
- **Part 9 (HPDA Standards):** Ensures all apps meet performance/quality criteria

**New Capabilities:**
- **Cross-Project Coordination:** Command Center sees entire ecosystem
- **Automated Enforcement:** Can auto-fix compliance issues
- **Central Repository:** Single source for all standards
- **Natural Language Interface:** AI-powered project management

---

### Changelog for v6.9

**v6.9 (October 1, 2025):**
- Added Part 10: Tempext Command Center - Central Project Coordination
- Introduced 8-domain architectural taxonomy (replaces generic categories)
- Mandated multi-volume project discovery (local + GitHub + internal registries)
- Required OpenCode AI tools for natural language project management
- Specified auto-update orchestration for broadcasting standard changes
- Defined central standards repository requirements
- Added domain-specific compliance rules
- Required notification protocols for critical issues
- Mandated data retention policies with permanent snapshots
- Specified Command Center maturity requirements (L3 minimum)
- Integrated mdBook documentation embedding (complements Part 9)
- Renamed "Master Librarian" to "Tempext Command Center" to reflect coordination role

**Compatibility:** v6.9 is backward-compatible with v6.8. All v6.8-compliant projects remain compliant under v6.9. The domain taxonomy provides additional classification but does not invalidate existing structures.

**Migration Path:** Organizations running v6.8 SHOULD:
1. Install Tempext Command Center (following Part 10 requirements)
2. Classify all projects into the 8 architectural domains
3. Configure multi-volume scanning (if projects span multiple locations)
4. Install OpenCode AI tools for natural language interface
5. Update project `.laio/constitution.yaml` to include domain classification

**Deprecations:** None. v6.9 is purely additive.

---

**End of TES-2025 v6.9 Updates**

**Status:** Gold  
**Next Review:** Upon Command Center MVP completion (approximately Gate 7)  
**Supersedes:** TES-2025 v6.8 (September 19, 2025)
